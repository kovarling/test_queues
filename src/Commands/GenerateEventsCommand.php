<?php
/**
 * ОПИСАНИЕ
 *
 * @link http://m1-call.ru/
 * @author Лютович Георгий <darkbober@gmail.com>
 * @copyright M1 Shop <m1-shop.ru>
 */

namespace App\Commands;


use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Process;

class GenerateEventsCommand extends Command
{
    CONST maxUsers = 1000;
    CONST maxEventsPerBatch = 10;
    const maxUsersPerBatch = 20;

    private $redisHost;
    private $redisPort;

    private $groupsList;

    private $redis;

    protected static $defaultName = 'test:generate_events';

    /**
     * @param $redisHost string
     * @param $redisPort string
     */
    public function __construct($redisHost, $redisPort)
    {
        parent::__construct();
        $this->redisHost = $redisHost;
        $this->redisPort = $redisPort;
        $this->groupsList = [];
        $this->redis = new \Redis();
        $this->redis->connect($this->redisHost, $this->redisPort);
    }

    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this
            ->addArgument('eventsAmount', InputArgument::REQUIRED, 'Number of event that would be added to queue')
        ;
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $redis = $this->redis;
        $redis->flushAll(); //очищаем весь кэш для исключения конфликтов. все запущенные обработчики сами закроются.

        $eventsCount = 0;
        while (true){
            $numUsers = $this->generateUsersBatchNumber();
            for($i = 0; $i < $numUsers; $i++){
                $userId = $this->generateUserId();
                $numEvents = $this->generateEventsBatchNumber();
                $eventsArray = [];
                for($eventNum = 0; $eventNum < $numEvents; $eventNum++){
                    $eventsArray[] = 'TestEvent'.$eventNum;
                    $eventsCount++;
                    if($eventsCount >= $input->getArgument('eventsAmount')){
                        break 3;
                    }
                }
                $groupNum = $this->getUserNormalizedGroup($userId);
                $this->addGroupToList($groupNum);

                $redis->lPush('group_'.$groupNum, $userId.':'.json_encode($eventsArray)); // разбиваем ивенты на группы по первой цифре из id юзера
            }
        }
        $output->writeln('в очередь помещено '.$input->getArgument('eventsAmount').' ивентов');

        $this->startQueueCommands($output);

        $this->waitForQueueToFinish($output);

        $redis->close();
        return Command::SUCCESS;
    }

    /**
     * Returns generated user id
     * @return int
     * @throws \Exception
     */
    private function generateUserId(): int
    {
        return random_int(1, self::maxUsers);
    }

    /**
     * Returns amount of events for current batch
     * @return int
     * @throws \Exception
     */
    private function generateEventsBatchNumber(): int
    {
        return random_int(1, self::maxEventsPerBatch);
    }

    /**
     * Returns amount of users for current batch
     * @return int
     * @throws \Exception
     */
    private function generateUsersBatchNumber(): int
    {
        return random_int(1, self::maxUsersPerBatch);
    }

    /**
     * returns group number based on user id
     * @param $userId
     * @return int
     */
    private function getUserNormalizedGroup($userId): int
    {
        $groupNum = (int) substr($userId, 0, 1);
        $groupNum += (int) ($userId >= 10?  substr($userId, 0, 1) : $groupNum);

        return $groupNum;
    }

    /**
     * Adds a new group to array of groups
     * @param $groupNum
     */
    private function addGroupToList($groupNum) : void
    {
        if(!in_array($groupNum, $this->groupsList)){
            $this->groupsList[] = $groupNum;
        }
    }

    /**
     * Runs commands with detached output for all existing queue groups
     * @throws \Exception
     */
    private function startQueueCommands(OutputInterface $output) : void
    {
        foreach ($this->groupsList as $groupNum){
            $output->writeln("$groupNum starting");
            $this->execInBackground("php bin/console test:queue_events $groupNum");
            $output->writeln("$groupNum started");
            /*$process->start();
            $pid = $process->getPid();
            $output->writeln("Worker started with PID: $pid");*/
        }
    }

    private function execInBackground($cmd) {
        if (substr(php_uname(), 0, 7) == "Windows"){
            pclose(popen("start /B ". $cmd, "r"));
        }
        else {
            exec($cmd . " > /dev/null &");
        }
    }

    /**
     * Generates output for queue groups
     * @param OutputInterface $output
     */
    private function waitForQueueToFinish(OutputInterface $output){
        while (!empty($this->groupsList)){
            foreach ($this->groupsList as $index=>$groupNum){
                $count = $this->redis->lLen('group_'.$groupNum);
                if($count == 0){
                    $output->writeln("Group $groupNum is processed completely");
                    unset($this->groupsList[$index]);
                } else {
                    $output->writeln("Group $groupNum has $count batches  of events");
                }
            }
            sleep(5);
        }
    }
}